SIGNAL(2)

НАЗВАНИЕ
signal - спецификация действий по обработке сигнала 

СИНТАКСИС 


        #include <signal.h>

        

        void (*signal (sig, func)) ( )

        int sig;

        void (*func) ( );


ОПИСАНИЕ
Системный вызов signal позволяет вызывающему процессу выбрать один из трех возможных способов реакции
на получение определенного сигнала. Аргументы sig и func специфицируют, соответственно, сигнал и выбор. 

Аргумент sig может иметь одно из следующих значений, за исключением SIGKILL: 
 SIGHUP
          01
                Освобождение линии (hangup).
 SIGINT
          02
                Прерывание (interrupt).
 SIGQUIT
          03
             [1]
                Выход (quit).
 SIGILL
          04
             [1]
                Некорректная команда (illegal instruction). Не переустанавливается при перехвате.
 SIGTRAP
          05
             [1]
                Трассировочное прерывание (trace trap). Не переустанавливается при перехвате.
 SIGIOT
          06
             [1]
                Машинная команда IOT.
 SIGABRT
          06
             [1]
                Рекомендуемый синоним предыдущего.
 SIGEMT
          07
             [1]
                Машинная команда EMT.
 SIGFPE
          08
             [1]
                Исключительная ситуация при выполнении операции с вещественными числами
                (floating-point exception).
 SIGKILL
          09
                Уничтожение процесса (kill). Не перехватывается и не игнорируется.
 SIGBUS
          10
             [1]
                Ошибка шины (bus error).
 SIGSEGV
          11
             [1]
                Некорректное обращение к сегменту памяти (segmentation violation).
 SIGSYS
          12
             [1]
                Некорректный параметр системного вызова (bad argument to system call).
 SIGPIPE
          13
                Запись в канал, из которого некому читать (write on a pipe with no one to read it).
 SIGALRM
          14
                Будильник (alarm clock).
 SIGTERM
          15
                Программный сигнал завершения (software termination signal).
 SIGUSR1
          16
                Определяемый пользователем сигнал 1 (user-defined signal 1).
 SIGUSR2
          17
                Определяемый пользователем сигнал 2 (user-defined signal 2).
 SIGCLD
          18
             [2]
                Завершение порожденного процесса (death of a child).
 SIGPWR
          19
             [2]
                Ошибка питания (power fail).
 SIGPOLL
          22
             [3]
                Регистрация выборочного события (selectable event pending).


Аргумент func может иметь одно из трех значений: SIG_DFL, SIG_IGN или адрес_функции. Макросы SIG_DFL
и SIG_IGN определены во включаемом файле <signal.h>. Каждый из макросов порождает уникальную
константу типа "указатель на функцию типа void", заведомо не соответствующую определяемой функции. 

Действия, предписываемые аргументом func, состоят в следующем: 

SIG_DFL - стандартная реакция на сигнал 
     При получении сигнала sig терминировать процесс со всеми завершающими действиями, описанными в
     exit(2); см. замечание [1] ниже. 
SIG_IGN - игнорирование сигнала 
     Игнорировать сигнал sig. Сигнал SIGKILL не может игнорироваться. 
адрес_функции - перехват сигнала 
     При получении сигнала sig выполнить функцию обработки сигнала func; в качестве единственного
     аргумента функции func передается номер сигнала sig; дополнительные аргументы передаются для
     сигналов, вырабатываемых аппаратурой. Перед выполнением функции func устанавливается стандартная
     реакция на полученный сигнал, если только этот сигнал не есть SIGILL или SIGTRAP. Таким образом,
     чтобы перехватить следующий сигнал sig, нужно вновь обратиться к signal, задав в качестве аргумента func
     адрес_функции. 

     После завершения функции обработки сигнала процесс, получивший сигнал, возобновляет выполнение с
     точки прерывания. 

     Если сигнал, который должен быть перехвачен, поступил во время выполнения системных вызовов
     read(2), write(2), open(2) или ioctl(2) для медленных устройств (таких, как терминал, но не дисковый файл),
     pause(2) или системного вызова wait(2), который не возвращает немедленно управление из-за того, что
     порожденный процесс остановлен или терминирован, то функция обработки сигнала выполняется, а
     затем прерванный системный вызов, скорее всего, возвращает вызывающему процессу значение -1 и
     присваивает переменной errno значение EINTR. 

     Системный вызов signal не проверяет корректность аргумента func. Последствия выполнения функции
     обработки сигнала, заданной некорректным адресом, непредсказуемы. 

     Сигнал SIGKILL перехватить нельзя. 

Выполнение системного вызова signal отменяет полученный, но еще не обработанный сигнал sig, если только
этот сигнал не есть SIGKILL. 

Системный вызов signal завершается неудачей, если: 

[EINVAL] 
     Значение аргумента sig является недопустимым номером сигнала, включая SIGKILL. 

ПРИМЕЧАНИЯ
[1] 

     Если для сигналов, помеченных
     [1], назначается стандартная реакция (SIG_DFL), то в дополнение к тому, что процесс
     терминируется, в текущем рабочем каталоге создается файл с образом памяти, если выполняются
     следующие условия: 

        1.Действующий и реальный идентификаторы пользователя процесса, получившего сигнал,
          совпадают. 
        2.Обычный файл с именем core существует и в него можно писать, или файл core может быть
          создан; создаваемый файл core будет обладать следующими характеристиками: 
             2.Режим доступа 0666, модифицированный маской режима создания файлов [см.
               umask(2)]. 
             3.Идентификатор владельца файла равен действующему идентификатору пользователя
               процесса, получившего сигнал. 
             4.Идентификатор группы файла равен действующему идентификатору группы процесса,
               получившего сигнал. 

[2] 

     Для сигналов SIGCLD и SIGPWR, как и для других, в качестве func может использоваться одно из
     трех значений: SIG_DFL, SIG_IGN или адрес функции обработки сигнала. Однако действия,
     предписываемые этими значениями, отличаются от описанных выше: 

     SIG_DFL - игнорирование сигнала
     SIG_IGN - игнорирование сигнала 

     Если значение sig равно SIGCLD, то процессы, порожденные вызывающим процессом, не перейдут
     в состояние зомби при своем завершении [см. exit(2)]. 

     адрес_функции - перехват сигнала
     Если получен сигнал SIGCLD, то на время выполнения функции обработки сигнала любой другой
     сигнал SIGCLD игнорируется. 

     Сигнал SIGCLD взаимодействует с системными вызовами wait и exit следующим образом: 

     wait 
          Если значение func для сигнала SIGCLD установлено равным SIG_IGN и выполняется
          системный вызов wait, то после получения сигнала SIGCLD wait блокируется до завершения
          всех процессов, порожденных вызывающим процессом; затем wait возвращает -1, а
          переменной errno присваивается значение ECHILD. 
     exit 
          Если процесс, родительский по отношению к процессу, выполняющему exit, установил для
          сигнала SIGCLD действие SIG_IGN, то завершающийся процесс не переходит в состояние
          зомби. 

     При использовании конвейера следует иметь в виду, что интерпретатор команд shell делает
     последний процесс конвейера родительским для предшествующих процессов. Процесс, который
     входит в конвейер (и таким образом может стать родительским процессом), не должен
     перехватывать сигнал SIGCLD. 

[3] 

     Сигнал SIGPOLL посылается, когда для дескриптора файла, соответствующего псевдоустройству
     [см. intro(2)], установлена регистрация выборочных событий. Процесс должен специально
     запрашивать посылку этого сигнала посредством системного вызова ioctl с аргументом I_SETSIG,
     иначе сигнал SIGPOLL никогда не будет получен. 

СМ. ТАКЖЕ
intro(2), kill(2), pause(2), ptrace(2), wait(2), setjmp(3C), sigset(2). kill(1) в Справочнике пользователя. 

ДИАГНОСТИКА
При успешном завершении системного вызова signal возвращается предыдущее значение func для указанного
сигнала sig. В противном случае возвращается значение SIG_ERR, а переменной errno присваивается код
ошибки. Значение SIG_ERR определено во включаемом файле <sys/signal.h>. 

СЮРПРИЗЫ
При попытке изменить стандартную реакцию на сигнал SIGKILL возвращается значение SIG_DFL (а не
SIG_ERR, как должно быть), а переменная errno получает значение EINVAL. 