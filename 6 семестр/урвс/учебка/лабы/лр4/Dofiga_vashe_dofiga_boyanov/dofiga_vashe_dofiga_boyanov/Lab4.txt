Министерство Образования Российской Федерации
Новосибирский Государственный Технический Университет



Кафедра программных систем и баз данных














Лабораторная работа №4
по курсу: Управление ресурсами в ОС UNIX


















Факультет: ПМИ
Группа: ПМ-07
Студентки: Гудович Т.А., Жданова А.А.
Преподаватель: Стасышин В.М.


Новосибирск, 2003
Задание
Разработать программу, вычисляющую значение f(x) как сумму ряда от k=1 до k=N от выражения (-1)**(k+1)*x**(2k-1)/(2k-1)! для значений x, равномерно распределенных на интервале [0,Пи], и выводящую полученный результат f(x) в файл в двоичном формате. В это время предварительно подготовленный процесс-потомок читает данные из файла, преобразовывает их в текстовую форму и выводит на экран до тех пор, пока процесс-предок не передаст ему через файл ключевое слово (например, "STOP"), свидетельствующее об окончании процессов.

Описание используемых команд
Для порождения нового процесса (процесс-потомок) используется системный вызов fork():                                                 int fork()
Ожидание завершения процесса-потомка родительским процессом выполняется с помощью системного вызова wait():
wait(int *status)
Системный вызов exit(), предназначенного для завершения функционирования процесса:                               void exit(int status)
В нашем  случае в рамках порожденного процесса загружается для выполнения программа, определенная  системным вызовом execl().Который осуществляет смену программы, определяющей функционирование данного  процесса:  
execl(name,arg0,arg1,...,argn,0)
char *name, *arg0, *arg1,...,*argn;
Для посылки сигнала используется системный вызов, имеющий формат
void kill(int pid, int sig)
Использование системного вызова signal() позволяет процессу самостоятельно определить свою реакцию на получение того или иного события (сигнала):
int (*signal(sig, func) ()
int sig; int (*func)();
Реакцией процесса, осуществившего системный вызов signal() с аргументом func, при получении сигнала sig будет вызов функции func().
Программный канал создается с помощью системного вызова pipe(), формат которого
int fd[2];
pipe(fd)
Открытие файла выполняется системным вызовом:
#include <fcntl.h>
 int open(file,O_RDONLY(для чтения))
	          O_WRONLY(для записи)
                      O_CREAT(создание)   
Системные вызовы 
для записи :       write(int h, void * buf,unsingen len),
и для чтения:      read(int h, void * buf,unsingen len)

Процедура запуска программы 
Запуск программы 4.1
 В данной программе все действия, относящиеся как к родительскому процессу, так и к порожденным процессам, выполняются в рамках одного исполняемого файла : lab4.c, запускаемый файл a.out .
Обмен данными между процессом-отцом и процессами-потомками осуществляется посредствам временного файла.
Запуск программы 4.2
Действия процесса-потомка реализуются отдельной программе lab42.c , запускаемой  системным вызовом execl() из процесса-потомка. Процесс-потомок, после порождения, начинают и завершают свое функционирование по сигналу, посылаемому процессом-предком. Обмен данными между процессами осуществляется через программный канал. 
Основной текст программы находится в файле lab41.c.


Текст программы
4.1
#include <stdio.h>
#include <math.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>
void main()
{
   int r,N,k,fd,i=1;
   float f,g,p,x,t;
   printf("enter N=");
   scanf("%d",&N);
   printf("enter X=");
   scanf("%f",&x);
   if (fork())
   {  /*Parent*/
      fd=open("a.txt",O_WRONLY|O_CREAT);
      t=x;
      for (k=1;k!=N;k++)
      {  
         f=f+pow(-1,k+1)*t;
         t=t*x*x/(2*k*(2*k+1));
         write (fd,&f,4);
      }
      f=0.;
      write (fd,&f,4);
      close (fd);
      wait(&k);
   }
   else
   {  /*Child*/
      fd=open("a.txt",O_RDONLY);
      while ((g!=0)||(i=0))
      {
         i=read(fd,&g,4);
         if (g!=0.) printf("%f\n",g);
      }
         exit(0);
   }
}
********************************************************************************
4.2
#include <stdio.h>
#include <math.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
void sign(int z)
{
;
}
void main()
{
   int r,N,k,i=1,pid,fd[2],xq;
   float f,g,p,x,t;
   char str1[10],str2[10];
   printf("enter N=");
   scanf("%d",&N);
   printf("enter X=");
   scanf("%f",&x);
    /*Parent*/
   pipe(fd); //open canal for reading and writing
   if (fork())
   {  /*Parent*/
      t=x;
      for (k=1;k!=N;k++)
      {
	  f=f+pow(-1,k+1)*t;
	  t=t*x*x/(2*k*(2*k+1));
	  write (fd[1],&f,4);
      }
      f=0.;
      write (fd[1],&f,4);
      kill(xq,30);
      sleep(5);
      kill(xq,9);
      printf("End of child\n");
      kill(pid,1);
      wait(&k);
    }
    else
    {  /*Child*/
      xq=getpid();
      signal(30,sign);
      printf("start child\n");
      //writing inode of canal
      sprintf(str1,"%d",fd[0]);
      sprintf(str2,"%d",fd[1]);
      //end signal
      signal(9,sign);
      execl("/root/LAB42.out","LAB42.out",str1,str2,0);
    }
}

********************************************************************************
#include <stdio.h>
#include <math.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>
void main(int argc,char *argv[])
{
    int i,k=0,fd[2];
    float g;
    sscanf(argv[1],"%d",&fd[0]);
    while ((g!=0.)||(i==0))
    {
       read(fd[0],&g,4);
       if (g!=0.) printf("%f\n",g);
    }
    exit(0);
}




