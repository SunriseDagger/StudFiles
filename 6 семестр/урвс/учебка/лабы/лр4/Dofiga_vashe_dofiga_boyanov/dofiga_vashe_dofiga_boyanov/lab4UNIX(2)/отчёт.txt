1. Задание.
I. Разработать программу, реализующую действия, указанные в задании к лабораторной работе с учетом следующих требований:
1.	все действия, относящиеся как к родительскому процессу, так и к порожденным процессам, выполняются в рамках одного исполняемого файла;
2.	обмен данными между процессом-отцом и процессом-потомком предлагается выполнить посредством временного файла: процесс-отец после порождения процесса-потомка постоянно опрашивает временный файл, ожидая появления в нем информации от процесса-потомка;
3.	если процессов-потомков несколько, и все они подготавливают некоторую информацию для процесса-родителя, каждый из процессов помещает в файл некоторую структурированную запись, при этом в этой структурированной записи содержатся сведения о том, какой процесс посылает запись, и сама подготовленная информация.
II. Модифицировать ранее разработанную программу с учетом следующих требований:
1.	действия процесса-потомка реализуются отдельной программой, запускаемой по одному из системных вызовов execl(), execv() и т.д. из процесса-потомка;
2.	процесс-потомок, после порождения, должен начинать и завершать свое функционирование по сигналу, посылаемому процессом-предком (это же относится и к нескольким процессам-потомкам);
3.	обмен данными между процессами необходимо осуществить через программный канал.

Наш вариант задания:
Разработать программу, вычисляющую число размещений по r ячейкам n элементов N=n!/n(1)!*n(2)!*...*n(r)!, удовлетворяющих требованию, что в ячейку с номером i попадает ровно n(i) элементов; i=1,...,r и n(1)+n(2)+...+n(r)=n. Для вычисления каждого из факториалов, должны быть порождены параллельные процессы-потомки.

2. Основные функции.
int fact (int k) – вычисление факториала;
void wr (int status, int ft) - вывод структурированной записи во временный файл;
status – положение факториала: UP (числитель), DOWN (знаменатель).
pid_t fork() – порождение процесса-потомка;
pid_t wait (int *status) – ожидание завершения работы процесса-потомка;
int pipe (int *fifo) – создание программного канала;
int signal (int sig, void (*func)(int)) – задание функции обработки сигнала;
int dup (int des) – дублирование дескриптора файла;
int execl (char* filename, char* programname, char param0[], …, char param[n], 0) – запуск программы из внешнего файла в рамках исходного процесса;
int kill (pid_t pid, int sig) – посылка сигнала процессу или группе процессов.

 
3. Особенности программы.
а) В исходных данных n сверху ограничено числом 12, т. к. 13! уже не входит в границы типа int.

б) Во второй части задания отлов сигнала производится следующим образом:
int flag = 1; //Глобальная переменная
…
void sigcatcher (int)
{
	flag = 0;
}
И затем в тексте программы:
while (flag); //Ждём сигнала

Такой вариант ожидания сигнала был выбран потому, что в таком случае сигнал поймается точно. Можно было вместо цикла while поставить системный вызов pause, но в таком случае есть вероятность, что сигнал придёт ранее выполнения данного системного вызова, и он будет проигнорирован.
Можно было поставить pause, а все осмысленные действия поместить в обработчик сигналов, но в таком случае сигнал может прийти до выполнения системного вызова signal, и он будет также утерян. Наша программа лишена такого недостатка, так как обработчик сигнала определяется ещё до порождения потомков. Конечно, и в рассмотренном случае можно было бы обработчик сигналов определить ещё до порождения потомка, но тогда отправлять сигналы процессам пришлось бы каждому индивидуально, а у нас отправляется сразу группе.
И, наконец, можно было каким-либо образом сообщать родительскому процессу о завершении работы системного вызова signal, поместив при этом все полезные действия в обработчик сигналов, а затем вызывать pause. Родительский процесс посылал бы сигнал только после завершения работы системного вызова signal у всех порождённых процессов. Этот способ и был бы наверное самым эффективным, но мы выбрали самый простой.
Наш метод также не лишён недостатков, т. к. при выполнении системного вызова pause процесс «замораживается», а у нас он продолжает выполнять действия, и, следовательно, отнимать процессорное время.

4. Текст программы.
Часть 1:
Файл lab4_1.cpp:
#include <stdlib.h>
#include <wait.h>
#include <unistd.h>
#include <stdio.h>

#define UP 0
#define DOWN 1

//Вычисляем факториал
int fact (int k)
{
	int fact = 1;
	while (k)
	{
		fact *= k;
		k--;
	}
	return fact;
}

//Вывод структурированной записи во временный файл
//status - UP (числитель), DOWN (знаменатель)
void wr (int status, int ft)
{
	FILE* out;
	out = fopen ("temp", "at+");
	if (!out)
	{
		printf ("Ошибка открытия файла для записи\n");
		exit (1);
	}
	fprintf (out, "%d %d\n", status, ft);
	fclose (out);
}

int main()
{
	int i, n, r, ft, status;
	int *mas;

	FILE* in;
	in = fopen ("temp", "wt"); //Очищаем файл от устаревшей информации
	fclose (in);

	printf ("Число размещений n элементов в r ячейках\n");
//Вводим исходные данные
	printf ("Введите n (1 - 12) ");
	scanf ("%d", &n);
	if (n > 12)
	{
		printf ("Факториал числа n выходит за границы int. Выберите число n от 1 до 12\n");
		return 1;
	}
	if (n < 0)
	{
		printf ("Число n не может быть отрицательным\n");
		return 1;
	}
	printf ("Введите r ");
	scanf ("%d", &r);

	mas = new int[r];

	status = 0;
	for (i = 0; i < r; i++)
	{
		printf ("Введите число элементов в ячейке %d ", i);
		scanf ("%d", &mas[i]);
		if (mas[i] < 0)
		{
			printf ("Числа n(i) не могут быть отрицательными\n");
			return 1;
		}
		status += mas[i];
	}

//Проверка на правильность исходных данных
	if (status != n)
	{
		printf ("Сумма n(i) не равна n\n");
		return 1;
	}

	if (fork() == 0) //Вычисление факториала в числителе
	{
		ft = fact (n);
		wr (UP, ft);
		return 0;
	}

	for (i = 0; i < r; i++) //Вычисление факториалов в знаменателе
	{
		if (fork() == 0)
		{
			ft = fact (mas[i]);
			wr (DOWN, ft);
			return 0;
		}
	}

	for (i = 0; i <= r; i++) //Ожидание завершения всех порождённых потомков
	{
		wait (&status);
		if (status != 0)
		{
			printf ("Произошла какая-то ошибка\n");
			return 1;
		}
	}

	in = fopen ("temp", "rt");

	if (!in)
	{
		printf ("Ошибка при чтении файла\n");
		return 1;
	}

	ft = 1;
	for (i = 0; i <= r; i++) //Чтение переданных данных и вычисление числа размещений
	{
		fscanf (in, "%d %d", &status, &n);
		if (status == UP)
			ft *= n;
		else
			ft /= n;
	}

	fclose (in);

	printf ("Число размещений: %d\n", ft);

	return 0;
}

Часть 2:
Файл lab4_21.cpp:
#include <stdlib.h>
#include <wait.h>
#include <unistd.h>
#include <stdio.h>

int flag = 1;

void sigcatcher (int) //Отлов сигнала от родителя для начала действий
{
	flag = 0;
}

int main()
{
	int i, j, k, n, r, ft, status;
	int *mas;

	int znam[2];
	int chisl[2];

	char chislo[10], tmp[10];

	pipe (znam);	//Канал для факториалов в знаменателе дроби
	pipe (chisl);	//Канал для факториала в числителе дроби

//Ввод исходных данных
	printf ("Число размещений n элементов в r ячейках\n");
	printf ("Введите n (1 - 12) ");
	scanf ("%d", &n);
	if (n > 12)
	{
		printf ("Факториал числа n выходит за границы int. Выберите число n от 1 до 12\n");
		return 1;
	}
	if (n < 0)
	{
		printf ("Число n не может быть отрицательным\n");
		return 1;
	}
	printf ("Введите r ");
	scanf ("%d", &r);

	mas = new int[r];

	status = 0;
	for (i = 0; i < r; i++)
	{
		printf ("Введите число элементов в ячейке %d ", i);
		scanf ("%d", &mas[i]);
		if (mas[i] < 0)
		{
			printf ("Числа n(i) не могут быть отрицательными\n");
			return 1;
		}
		status += mas[i];
	}

//Проверка на правильность исходных данных
	if (status != n)
	{
		printf ("Сумма n(i) не равна n\n");
		return 1;
	}

	signal (SIGINT, sigcatcher); //Задаём функцию обработки сигнала

	status = 1;

	if (fork() == 0) //Вычисление факториала в числителе
	{
		while (flag); //Ждём сигнала
		//Раскладываем число в строку
		i = 0;
		while (n)
		{
			chislo[i] = n % 10 + '0';
			n /= 10;
			i++;
		}
		tmp[i] = '\0';
		i--;
		k = 0;
		while (i >= 0)
		{
			tmp[k] = chislo[i];
			i--;
			k++;
		}
		close (1); //Закрываем стандартный вывод
		dup (chisl[1]); //И переназначаем на него канал
		execl ("lab4_22", "lab4_22", tmp, 0); //Вызываем программу подсчёта факториала
		return 0;
	}

	for (i = 0; i < r; i++) //Вычисление факториалов в знаменателе
	{
		if (fork() == 0)
		{
			while (flag); //Ждём сигнала
			//Раскладываем число в строку
			j = 0;
			while (mas[i])
			{
				chislo[j] = mas[i] % 10 + '0';
				mas[i] /= 10;
				j++;
			}
			tmp[j] = '\0';
			j--;
			k = 0;
			while (j >= 0)
			{
				tmp[k] = chislo[j];
				j--;
				k++;
			}
			close (1); //Закрываем стандартный вывод
			dup (znam[1]); //И переназначаем на него канал
			execl ("lab4_22", "lab4_22", tmp, 0); //Вызываем программу подсчёта факториала
			return 0;
		}
	}

	kill (-getpgrp(), SIGINT); //Посылаем сигнал потомкам (и себе) для начала работы

	for (i = 0; i <= r; i++) //Ожидание завершения всех порождённых потомков
	{
		wait (&status);
		if (status != 0)
		{
			printf ("Произошла какая-то ошибка\n");
			return 1;
		}
	}

	//Чтение переданных данных и вычисление числа размещений
	ft = 1;
	read (chisl[0], &n, sizeof(int)); //Считываем факториал в числителе - n!
	ft *= n;

	for (i = 0; i < r; i++) //Считываем факториалы знаменателя
	{
		read (znam[0], &n, sizeof(int));
		ft /= n;
	}

	printf ("Число размещений: %d\n", ft);

	return 0;
}

Файл lab4_22.cpp:
#include <string.h>
#include <unistd.h>
#include <stdio.h>

int fact (int k) //Вычисление факториала
{
	int fact = 1;
	while (k)
	{
		fact *= k;
		k--;
	}
	return fact;
}

int main (int argc, char* argv[])
{
	int ch = 0;
	int i = 0;
	while (argv[1][i] != '\0') //Преобразуем строку в число
	{
		ch *= 10;
		ch += argv[1][i] - '0';
		i++;
	}
	ch = fact (ch);
	write (1, &ch, sizeof(int)); //Выводим в канал полученное значение
	return 0;
}