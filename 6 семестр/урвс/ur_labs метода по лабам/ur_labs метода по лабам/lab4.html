<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

 <head>
  <title>Лабораторная работа № 4</title>
  <meta http-equiv=Content-Type content="text/html; charset=windows-1251">
  <link rel="stylesheet" type="text/css" href="textstyle.css">
  <!--base href="http://ami.nstu.ru/~vms/method6/"-->
 </head>

 <body>

  <div class="header">
   Лабораторная работа № 4
  </div>
  <div class="mainheader">
   Порождение нового процесса и работа с ним. запуск программы в рамках порожденного процесса. Сигналы и каналы в ОС UNIX
  </div>
  
  <div class="header">
   Цель работы
  </div>
  <div class="abzac">
   Изучить программные средства создания процессов, получить навыки управления и синхронизации процессов, а также простейшие 
   способы обмена данными между процессами. Ознакомиться со средствами динамического запуска программ в рамках порожденного 
   процесса, изучить механизм сигналов ОС UNIX, позволяющий процессам реагировать на различные события, и каналы, как одно 
   из средств обмена информацией между процессами.   
  </div>
  
  <div class="header">
   Содержание работы
  </div>
  <ol>
   <li>
    Изучить правила использования системных вызовов <span class="code">fork()</span>, <span class="code">wait()</span>, <span class="code">exit()</span>. 
   </li>
   <li>
    Ознакомиться с системными вызовами <span class="code">getpid()</span>, <span class="code">getppid()</span>, 
    <span class="code">sеtpgrp()</span>, <span class="code">getpgrp()</span>. 
   </li>
   <li>
    Изучить средства динамического запуска программ в ОС UNIX (системные вызовы <span class="code">execl()</span>, <span class="code">execv()</span>,...). 
   </li>
   <li>
    Изучить средства работы с сигналами и каналами в ОС UNIX. 
   </li>
   <li>
    Ознакомиться с заданием к лабораторной работе. 
   </li>
   <li>
    Для указанного варианта составить программу на языке Си, реализующую задание. 
   </li>
   <LI>
    Отладить и оттестировать составленную программу, используя инструментарий ОС UNIX. 
   </li>
   <li>
    Защитить лабораторную работу, ответив на контрольные вопросы.
   </li>
  </ol>

  <div class="header">
   Методические указания к лабораторной работе
  </div>
  <div class="abzac">
   Для порождения нового процесса (процесс-потомок) используется системный вызов <span class="code">fork()</span>. Формат вызова:
  </div>
<pre>
int fork();
</pre>
  <div class="abzac">
   Порожденный таким образом процесс представляет собой точную копию своего процесса-предка. Единственное различие между ними 
   заключается в том, что процесс-потомок в качестве возвращаемого значения системного вызова <span class="code">fork()</span> получает 0, а процесс-предок - 
   идентификатор процесса-потомка. Кроме того, процесс-потомок наследует и весь контекст программной среды, включая дескрипторы 
   файлов, каналы и т.д. Наличие у процесса идентификатора дает возможность и ОС UNIX, и любому другому пользовательскому 
   процессу получить информацию о функционирующих в данный момент процессах.
  </div>
  <div class="abzac">
   Ожидание завершения процесса-потомка родительским процессом выполняется с помощью системного вызова <span class="code">wait()</span>:
  </div>
<pre>
int wait(int *status);
</pre>
  <div class="abzac">
   В результате осуществления процессом системного вызова <span class="code">wait()</span> функционирование процесса 
   приостанавливается до момента завершения порожденного им процесса-потомка. По завершении процесса-потомка процесс-предок 
   пробуждается и в качестве возвращаемого значения системного вызова <span class="code">wait()</span> получает идентификатор 
   завершившегося процесса-потомка, что позволяет процессу-предку определить, какой из его процессов-потомков завершился 
   (если он имел более одного процесса-потомка). Аргумент системного вызова <span class="code">wait()</span> представляет 
   собой указатель на целочисленную переменную <span class="code">status</span>, которая после завершения выполнения этого 
   системного вызова будет содержать в старшем байте код завершения процесса-потомка, установленный последним в качестве 
   системного вызова <span class="code">exit()</span>, а в младшем - индикатор причины завершения процесса-потомка.
  </div>
  <div class="abzac">
   Формат системного вызова <span class="code">exit()</span>, предназначенного для завершения функционирования процесса:
  </div>
<pre>
int exit(int status);
</pre>
  <div class="abzac">
   Аргумент <span class="code">status</span> является статусом завершения, который передается отцу процесса, если он 
   выполнял системный вызов <span class="code">wait()</span>.
  </div>
  <div class="abzac">
   Для получения собственного идентификатора процесса используется системный вызов <span class="code">getpid()</span>, 
   а для получения идентификатора процесса-отца - системный вызов <span class="code">getppid()</span>:
  </div>
<pre>
int getpid();
int getppid();
</pre>
  <div class="abzac">
   Вместе с идентификатором процесса каждому процессу в ОС UNIX ставится в соответствие также идентификатор группы процессов. 
   В группу процессов объединяются все процессы, являющиеся процессами-потомками одного и того же процесса. Организация новой 
   группы процессов выполняется системным вызовом <span class="code">getpgrp()</span>, а получение собственного идентификатора 
   группы процессов - системным вызовом <span class="code">getpgrp()</span>. Их формат:
  </div>
<pre>
int setpgrp();
int getpgrp();
</pre>
  <div class="abzac">
   С практической точки зрения в большинстве случаев в рамках порожденного процесса загружается для выполнения программа, 
   определенная одним из системных вызовов <span class="code">execl()</span>, <span class="code">execv()</span>,... Каждый 
   из этих системных вызовов осуществляет смену программы, определяющей функционирование данного процесса:
  </div>
<pre>
execl(name, arg0, arg1, ... , argn, 0)
char *name, *arg0, *arg1, ... , *argn;

execv(name, argv)
char *name, *argv[];

execle(name, arg0, arg1, ... , argn, 0, envp)
char *name, *arg0, *arg1, ... , *argn, *envp[];

execve(name, argv, envp)
char *name, *arg[], *envp[];
</pre>
  <div class="abzac">
   Сигналы - это программное средство, с помощью которого может быть прервано функционирование процесса в ОС UNIX. 
   Механизм сигналов позволяет процессам реагировать на различные события, которые могут произойти в ходе функционирования 
   процесса внутри него самого или во внешнем мире. Каждому сигналу ставятся в соответствие номер сигнала и строковая 
   константа, используемая для осмысленной идентификации сигнала. Эта взаимосвязь отображена в файле описаний <span class="code">signal.h</span>. 
   Для посылки сигнала используется системный вызов, имеющий формат:
  </div>
<pre>
void kill(int pid, int sig);
</pre>
  <div class="abzac">
   В результате осуществления такого системного вызова сигнал, специфицированный аргументом <span class="code">sig</span>, 
   будет послан процессу, который имеет идентификатор <span class="code">pid</span>. Если <span class="code">pid</span> не 
   превосходит 1, сигнал будет послан целой группе процессов.
  </div>
  <div class="abzac">
   Использование системного вызова <span class="code">signal()</span> позволяет процессу самостоятельно определить свою 
   реакцию на получение того или иного события (сигнала):
  </div>
<pre>
int sig; 
int (*func)();
int *signal(sig, func) ();
</pre>
  <div class="abzac">
   Реакцией процесса, осуществившего системный вызов <span class="code">signal()</span> с аргументом <span class="code">func</span>, 
   при получении сигнала <span class="code">sig</span> будет вызов функции <span class="code">func()</span>.
  </div>
  <div class="abzac">
   Системный вызов <span class="code">pause()</span> позволяет приостановить процесс до тех пор, пока не будет получен какой-либо сигнал:
  </div>
<pre>
void pause();
</pre>
  <div class="abzac">
   Системный вызов <span class="code">alarm(n)</span> обеспечивает посылку процессу сигнала <span class="code">SIGALARM</span> 
   через <span class="code">n</span> секунд.
  </div>
  <div class="abzac">
   В ОС UNIX существует специальный вид взаимодействия между процессами - программный канал. Программный канал создается 
   с помощью системного вызова <span class="code">pipe()</span>, формат которого:
  </div>
<pre>
int fd[2];
pipe(fd);
</pre>
  <div class="abzac">
   Системный вызов <span class="code">pipe()</span> возвращает два дескриптора файла: один для записи данных в канал, 
   другой - для чтения. После этого все операции передачи данных выполняются с помощью системных вызовов ввода-вывода 
   <span class="code">read/write</span>. При этом система ввода-вывода обеспечивает приостановку процессов, если канал 
   заполнен (при записи) или пуст (при чтении). Таких программных каналов процесс может установить несколько. Отметим, 
   что установление связи через программный канал опирается на наследование файлов. Взаимодействующие процессы должны 
   быть родственными.
  </div>

  <div class="header">
   Задание к лабораторной работе
  </div>
  <ol>
   <li>
    Разработать программу, реализующую действия, указанные в задании к лабораторной работе с учётом следующих требований:
    <ul>
     <li>
      все действия, относящиеся как к родительскому процессу, так и к порожденным процессам, выполняются в рамках одного исполняемого файла;
     </li>
     <li>
      обмен данными между процессом-отцом и процессом-потомком предлагается выполнить посредством временного файла: 
      процесс-отец после порождения процесса-потомка постоянно опрашивает временный файл, ожидая появления в нем 
      информации от процесса-потомка;
     </li>
     <li>
      если процессов-потомков несколько, и все они подготавливают некоторую информацию для процесса-родителя, каждый 
      из процессов помещает в файл некоторую структурированную запись, при этом в этой структурированной записи 
      содержатся сведения о том, какой процесс посылает запись, и сама подготовленная информация.
     </li>
    </ul>
   </li>
   <li>
    Модифицировать ранее разработанную программу с учётом следующих требований:
    <ul>
     <li>
      действия процесса-потомка реализуются отдельной программой, запускаемой по одному из системных вызовов 
      <span class="code">execl()</span>, <span class="code">execv()</span> и т.д. из процесса-потомка;
     </li>
     <li>
      процесс-потомок, после порождения, должен начинать и завершать свое функционирование по сигналу, посылаемому 
      процессом-предком (это же относится и к нескольким процессам-потомкам);
     </li>
     <li>
      обмен данными между процессами необходимо осуществить через программный канал.
     </li>
    </ul>
   </li>
  </ol>

  <div class="header">
   Варианты заданий
  </div>
  <ol>
   <li>
    Разработать программу, вычисляющую интеграл на отрезке <span class="code">[A;B]</span> от функции <span class="code">exp(x)</span> 
    методом трапеций, разбивая интервал на <span class="code">K</span> равных отрезков. Для нахождения <span class="code">exp(х)</span> 
    программа должна породить процесс, вычисляющий её значение путём разложения в ряд по формулам вычислительной математики.
   </li>

   <li>
    Разработать программу, вычисляющую значение <span class="code">f(x)</span> как сумму ряда от <span class="code">k=0</span> до 
    <span class="code">k=N</span> от выражения <span class="code">x^(2k+1)/(2k+1)!</span> для значений <span class="code">x</span>, 
    равномерно распределённых на интервале <span class="code">[0;Pi]</span>, и выводящую полученный результат 
    <span class="code">f(x)</span> в файл в двоичном формате. В это время предварительно подготовленный процесс-потомок читает 
    данные из файла, преобразовывает их в текстовую форму и выводит на экран до тех пор, пока процесс-предок не передаст 
    ему через файл ключевое слово (например, "STOP"), свидетельствующее об окончании процессов. 
   </li>

   <li>
    Разработать программу, вычисляющую плотность распределения Пуассона с параметром <span class="code">lambda</span> в точке 
    <span class="code">k</span> (<span class="code">k</span> - целое) по формуле <span class="code">f(k)=lambda^k*exp(-lambda)/k!</span>. 
    Для нахождения факториала и <span class="code">exp(-lambda)</span> программа должна породить два параллельных 
    процесса, вычисляющих эти величины путём разложения в ряд по формулам вычислительной математики.
   </li>

   <li>
    Разработать программу, вычисляющую плотность выпуклого распределения в точке <span class="code">х</span> по формуле 
    <span class="code">f(x)=(1-cos(x))/(Pi*x^2)</span>. Для нахождения <span class="code">Pi</span> и 
    <span class="code">cos(х)</span> программа должна породить два параллельных процесса, вычисляющих эти величины путём 
    разложения в ряд по формулам вычислительной математики. 
   </li>

   <li>
    Разработать программу, вычисляющую значение плотности лог-нормального распределения в точке <span class="code">х</span> 
    (<span class="code">x&gt;0</span>) по формуле <span class="code">f(x)=(1/2)*exp(-(1/2)*ln(x)^2)/(x*sqrt(2*Pi))</span>. 
    Для нахождения <span class="code">Pi</span>, <span class="code">exp(x)</span> и <span class="code">ln(x)</span> программа 
    должна породить три параллельных процесса, вычисляющих эти величины путём разложения в ряд по формулам вычислительной математики. 
   </li>

   <li>
    Разработать программу, вычисляющую число размещений <span class="code">n</span> элементов по <span class="code">r</span> 
    ячейкам <span class="code">N=n!/n(1)!*n(2)!*...*n(r)!</span>, удовлетворяющее требованию, что в ячейку с номером <span class="code">i</span> 
    попадает ровно <span class="code">n(i)</span> элементов (<span class="code">i=1..r</span>) и <span class="code">n(1)+n(2)+...+n(r)=n</span>. 
    Для вычисления каждого факториала необходимо породить процесс-потомок. 
   </li>

   <li>
    Разработать программу, вычисляющую число сочетаний <span class="code">C(k,n)=n!/(k!*(n-k)!)</span>. Для вычисления 
    факториалов <span class="code">n!</span>, <span class="code">k!</span>, <span class="code">(n-k)!</span> должны быть 
    порождены три параллельных процесса-потомка. 
   </li>

   <li>
    Разработать программу, вычисляющую значение <span class="code">f(x)</span> как сумму ряда от <span class="code">k=1</span> 
    до <span class="code">k=N</span> от выражения <span class="code">(-1)^(k+1)*x^(2k-1)/(2k-1)!</span> для значений <span class="code">x</span>, 
    равномерно распределённых на интервале <span class="code">[0;Pi]</span>, и выводящую полученный результат 
    <span class="code">f(x)</span> в файл в двоичном формате. В это время предварительно подготовленный процесс-потомок читает данные 
    из файла, преобразовывает их в текстовую форму и выводит на экран до тех пор, пока процесс-предок не передаст ему через 
    файл ключевое слово (например, "STOP"), свидетельствующее об окончании процессов. 
   </li>

   <li>
    Разработать программу, вычисляющую плотность нормального распределения в точке <span class="code">x</span> по формуле 
    <span class="code">f(x)=exp(-x^2/2)/sqrt(2*Pi)</span>. Для нахождения <span class="code">Pi</span> и 
    <span class="code">exp(-x^2/2)</span> программа должна породить два параллельных процесса, вычисляющих эти величины 
    путём разложения в ряд по формулам вычислительной математики. 
   </li>

   <li>
    Разработать программу, вычисляющую интеграл в диапазоне от 0 до 1 от подинтегрального выражения <span class="code">4*dx/(1+x^2)</span> 
    с помощью последовательности равномерно распределённых на отрезке <span class="code">[0;1]</span> случайных чисел, которая 
    генерируется процессом-потомком параллельно. Процесс-потомок должен завершиться после заранее заданного числа генераций 
    <span class="code">N</span>.
   </li>

  </ol>

  <div class="header">
   Контрольные вопросы
  </div>
  <ol>
   <li>
    Каким образом может быть порожден новый процесс? Какова структура нового процесса?
   </li>
   <li>
    Если процесс-предок открывает файл, а затем порождает процесс-потомок, а тот, в свою очередь, изменяет положение указателя 
    чтения-записи файла, то изменится ли положение указателя чтения-записи файла процесса-отца?
   </li>
   <li>
    Что произойдет, если процесс-потомок завершится раньше, чем процесс-предок осуществит системный вызов <span class="code">wait()</span>?
   </li>
   <li>
    Могут ли родственные процессы разделять общую память?
   </li>
   <li>
    Каков алгоритм системного вызова <span class="code">fork()</span>?
   </li>
   <li>
    Какова структура таблиц открытых файлов, файлов и описателей файлов после создания процесса?
   </li>
   <li>
    Каков алгоритм системного вызова <span class="code">exit()</span>?
   </li>
   <li>
    Каков алгоритм системного вызова <span class="code">wait()</span>?
   </li>
   <li>
    В чем разница между различными формами системных вызовов типа <span class="code">exec()</span>?
   </li>
   <li>
    Для чего используются сигналы в ОС UNIX?
   </li>
   <li>
    Какие виды сигналов существуют в ОС UNIX? 
   </li>
   <li>
    Для чего используются каналы?
   </li>
   <li>
    Какие требования предъявляются к процессам, чтобы они могли осуществлять обмен данными посредством каналов? 
   </li>
   <li>
    Каков максимальный размер программного канала и почему?
   </li>
  </ol>

 </body>
</html>
