<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

 <head>
  <title>Лабораторная работа № 8</title>
  <meta http-equiv=Content-Type content="text/html; charset=windows-1251">
  <link rel="stylesheet" type="text/css" href="textstyle.css">
  <!--base href="http://ami.nstu.ru/~vms/method6/"-->
 </head>

 <body>

  <div class="header">
   Лабораторная работа № 8
  </div>
  <div class="mainheader">
   Клиент-серверные взаимодействия посредством сокетов в режиме TCP-соединения
  </div>
  
  <div class="header">
   Цель работы
  </div>
  <div class="abzac">
   Практическое освоение механизма сокетов. Построение TCP-соединений для межпроцессного взаимодействия программ 
   клиента и сервера в модели "клиент-сервер".
  </div>
  
  <div class="header">
   Содержание работы
  </div>
  <ol>
   <li>
    Ознакомиться с заданием к лабораторной работе. 
   </li>
   <li>
    Ознакомиться с понятиями сокета, моделей взаимодействия между процессами на основе сокетов, структурами данных 
    и адресацией, используемых при работе с сокетами, основными шагами при организации взаимодействия процессов в 
    сети в режиме TCP-соединения.
   </li>
   <li>
    Для указанного варианта составить на языке Си две программы: программу сервера и программу клиента, реализующие 
    требуемые действия. 
   </li>
   <li>
    Выбрать и изучить набор системных вызовов, обеспечивающих решение задачи. 
   </li>
   <LI>
    Отладить и оттестировать составленную программу, используя инструментарий ОС UNIX. 
   </li>
   <li>
    Защитить лабораторную работу, ответив на контрольные вопросы.
   </li>
  </ol>

  <div class="header">
   Методические указания к лабораторной работе
  </div>
  <div class="abzac">
   Существует две модели взаимодействия между процессами в сети: модель соединений с протоколом TCP (Transmission 
   Control Protocol), и модель дейтаграмм с протоколом UDP (User Datagram Protocol). В данной лабораторной работе 
   используется первая из названных моделей.
  </div>
  <div class="abzac">
   Далее приводятся основные шаги и необходимые системные вызовы для выполнения основных этапов при работе с 
   сокетами в режиме TCP-соединения.
  </div>

  <div class="header">
   1. Адресация и создание сокета
  </div>
  <div class="abzac">
   Совокупная информация об адресе, порте программы-адресата (абонента), модели соединения, протоколе взаимодействия 
   составляет так называемый сокет (конечная абонентская точка), формально представляющий собой структуру данных. 
   Существует несколько видов сокетов: 
  </div>
  <ul>
   <li>
    обобщенный сокет (generic socket), определяется в файле <span class="code">&lt;sys/socket.h&gt;</span>:
<pre>
struct sockaddr 
{ 
 u_char sa_family; /* Семейство адресов (домен) */
 char sa_data[];   /* Адрес сокета */
}; 
</pre>
   </li>
   <li>
    сокеты для связи через сеть, определяются в файле <span class="code">&lt;netinet/in.h&gt;</span>
<pre>
struct sockaddr_in 
{
 u_char sin_len;          /* Длина поля sockaddr_in (для FreeBSD) */
 u_char sin_family;       /* Семейство адресов (домен) */
 u_short sin_port;        /* Номер порта */
 struct in_addr sin_addr; /* IP-адрес */
 char sin_zero[8];        /* Поле выравнивания */
};
</pre>
    где 
<pre>
struct in_addr 
{
 n_int32_t s_addr
};
</pre>
   </li>
  </ul>
  <div class="abzac">
   Создается сокет при помощи системного вызова <span class="code">socket()</span>
  </div>
<pre>
#include &lt;sys/socket.h&gt;
int socket (int domain, int type, int protocol);
</pre>
  <ul>
   <li>
    параметр <span class="code">domain</span> - домен связи, в котором будет использоваться сокет (значение <span class="code">AF_INET</span> - 
    для домена <span class="code">Internet</span> (соединение через сеть), <span class="code">AF_UNIX</span> - домен, если процессы находятся на одном и 
    том же компьютере); 
   </li>
   <li>
    параметр <span class="code">type</span> определяет тип создаваемого сокета (значение <span class="code">SOCK_STREAM</span> - 
    для режима соединений, <span class="code">SOCK_DGRAM</span> - для режима дейтаграмм);
   </li>
   <li>
    Параметр <span class="code">protocol</span> определяет используемый протокол (в случае <span class="code">protocol=0</span> по умолчанию 
    для сокета типа <span class="code">SOCK_STREAM</span> будет использовать протокол TCP, а для сокета типа 
    <span class="code">SOCK_DGRAM</span> - протокол UDP).
   </li>
  </ul>
  <div class="abzac">
   При программировании TCP-соединения должны быть созданы сокеты (системный вызов <span class="code">socket()</span>) и в программе 
   сервера, и в программе клиента, при этом в обеих программах сокеты связываются с адресом машины, на которую будет установлена 
   программа сервера. Но, если в программе сервера для определения IP-адреса в структуре сокета может быть использована 
   переменная <span class="code">INADDR_ANY</span>, то в программе клиента для занесения в структуру сокета IP-адреса машины сервера 
   необходимо использовать системный вызов <span class="code">inet_addr()</span>.
  </div>
  <div class="abzac">
   Сетевые вызовы <span class="code">inet_addr()</span> и <span class="code">inet_ntoa()</span> выполняют преобразования 
   IP-адреса из формата текстовой строки <span class="code">"x.y.z.t"</span> в структуру типа <span class="code">in_addr</span> и обратно.
  </div>
<pre>
#include &lt;arpa/inet.h&gt;
in_addr_t inet_addr (const char *ip_address);
char * inet_ntoa(const struct in_addr in);
</pre>
  <div class="abzac">
   Для того чтобы процесс мог ссылаться на адрес своего компьютера, в файле <span class="code">&lt;netinet/in.h&gt;</span> 
   определена переменная <span class="code">INADDR_ANY</span>, содержащая локальный адрес компьютера в формате <span class="code">in_addr_t</span>.
  </div>

  <div class="header">
   2. Связывание
  </div>
  <div class="abzac">
   Системный вызов <span class="code">bind()</span> связывает сетевой адрес компьютера с идентификатором сокета.
  </div>
<pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int bind (int sockfd, const struct sockaddr *address, size_t add_len);
</pre>
  <ul>
   <li>
    <span class="code">sockfd</span> - дескриптор файла сокета, созданным с помощью вызова <span class="code">socket()</span>;
   </li>
   <li>
    <span class="code">address</span> - указатель на обобщённую структуру адреса сокета, к которой преобразуется структура 
    <span class="code">sockaddr_in</span> в случае передачи данных через сеть;
   </li>
   <li>
    <span class="code">size_t add_len</span> - размер указанной структуры адреса сокета.
   </li>
  </ul>
  <div class="abzac">
   В случае успешного завершения вызова <span class="code">bind()</span> он возвращает значение 0. В случае ошибки, например, если 
   сокет для этого адреса уже существует, вызов <span class="code">bind()</span> возвращает значение -1. Переменная <span class="code">errno</span> будет 
   иметь при этом значение <span class="code">EADDRINUSE</span>.
  </div>
  <div class="abzac">
   Операция связывания выполняется только в программе сервера.
  </div>

  <div class="header">
   3. Включение приема TCP-соединений
  </div>
  <div class="abzac">
   После выполнения связывания с адресом и перед тем, как какой-либо клиент сможет подключиться к созданному сокету, 
   сервер должен включить прием соединений посредством системного вызова <span class="code">listen()</span>:
  </div>
<pre>
#include &lt;sys/socket.h&gt;
int listen (int sockfd, int queue_size);
</pre>
  <ul>
   <li>
    <span class="code">sockfd</span> - дескриптор файла сокета, созданный с помощью вызова <span class="code">socket()</span>;
   </li>
   <li>
    <span class="code">queue_size</span> - число запросов на соединение с сервером, которые могут стоять в очереди.
   </li>
  </ul>
  <div class="abzac">
   Данная операция выполняется только в программе сервера.
  </div>

  <div class="header">
   4. Прием запроса на установку TCP-соединения
  </div>
  <div class="abzac">
   Когда сервер получает от клиента запрос на соединение, он создаёт новый сокет для работы с новым соединением. Первый 
   же сокет используется только для установки соединения. Дополнительный сокет для работы с соединением создаётся при помощи 
   вызова <span class="code">accept()</span>, принимающего очередное соединение:
  </div>
<pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int accept (int sockfd, struct sockaddr *address, size_t *add_len);
</pre>
  <ul>
   <li>
    <span class="code">sockfd</span> - дескриптор сокета, для которого ведется прием соединений; 
   </li>
   <li>
    <span class="code">address</span> - указатель на обобщенную структуру адреса сокета с информацией о клиенте; так как связь использует 
    соединение адрес клиента знать не обязательно и допустимо задавать параметр <span class="code">address</span> значением 
    <span class="code">NULL</span>; 
   </li>
   <li>
    <span class="code">add_len</span> - размер структуры адреса, заданной параметром <span class="code">address</span>, если 
    значение address не равно <span class="code">NULL</span>.
   </li>
  </ul>
  <div class="abzac">
   Возвращаемое значение соответствует идентификатору нового сокета, который будет использоваться для связи. До 
   тех пор, пока от клиента не поступил запрос на соединение, процесс, выдавший системный вызов 
   <span class="code">accept()</span> переводится в состояние ожидания.
  </div>
  <div class="abzac">
   Данная операция выполняется только в программе сервера.
  </div>

  <div class="header">
   5. Подключение клиента
  </div>
  <div class="abzac">
   Для выполнения запроса на подключение к серверному процессу клиент использует системный вызов <span class="code">connect()</span>:
  </div>
<pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
int connect (int csockfd, const struct sockaddr *address, size_t add_len);
</pre>
  <ul>
   <li>
    <span class="code">сsockfd</span> - дескриптор файла сокета клиента, созданным с помощью вызова <span class="code">socket()</span>; 
   </li>
   <li>
    <span class="code">address</span> - указателем на обобщенную структуру адреса сокета, к которой преобразуется структура 
    <span class="code">sockaddr_in</span>, в случае передачи данных через сеть; 
   </li>
   <li>
    <span class="code">size_t add_len</span> - размер указанной структуры адреса сокета.
   </li>
  </ul>
  <div class="abzac">
   В случае успешного завершения вызова <span class="code">connect()</span> он возвращает значение 0. В случае ошибки, 
   системный вызов <span class="code">connect()</span> возвращает значение -1, а переменная <span class="code">errno</span> идентифицирует ошибку.
  </div>
  <div class="abzac">
   Данная операция выполняется только в программе клиента.
  </div>

  <div class="header">
   6. Пересылка данных
  </div>
  <div class="abzac">
   Для сокетов типа <span class="code">SOCK_STREAM</span> дескрипторы сокетов, полученные сервером посредством вызова 
   <span class="code">accept()</span> и клиентом с помощью вызова <span class="code">socked()</span>, могут использоваться для чтения или записи. 
   Для этого могут использоваться обычные вызовы <span class="code">read()</span> и <span class="code">write()</span>, либо специальные системные 
   вызовы <span class="code">send()</span> и <span class="code">recv()</span>, позволяющие задавать дополнительные параметры пересылки данных по сети. 
   Синхронизация данных при работе с сокетом аналогична передаче данных через программный канал. 
  </div>
<pre>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
ssize_t recv (int sockfd, void *buffer, size_t length, int flags);
ssize_t send (int sockfd, const void *buffer, size_t length, int flags);
</pre>
  <ul>
   <li>
    <span class="code">socfd</span> - дескриптор сокета, через который читаются или записываются данные;
   </li>
   <li>
    <span class="code">buffer</span> - буфер, в который они помещаются или откуда отсылаются через сокет; 
   </li>
   <li>
    <span class="code">length</span> - размер буфера; 
   </li>
   <li>
    <span class="code">flags</span> - поле дополнительных опций при получении или передаче данных.
   </li>
  </ul>
  <div class="abzac">
   В случае успешного чтения/записи системные вызовы <span class="code">send()</span> и <span class="code">recv()</span> возвращают число прочитанных/отосланных 
   байт, или -1 в случае ошибки; в случае разорванной связи (клиент разорвал TCP-соединение) вызов 
   <span class="code">recv()</span> (или <span class="code">read()</span>) возвращают нулевое значение; если процесс пытается записать данные через 
   разорванное TCP-соединение посредством <span class="code">write()</span> или <span class="code">send()</span>, то он получает сигнал 
   <span class="code">SIGPIPE</span>, который можно обработать, если предусмотрена обработка данного сигнала.
  </div>
  <div class="abzac">
   В случае <span class="code">flags=0</span> вызовы <span class="code">send()</span> и <span class="code">recv()</span> полностью 
   аналогичны системным вызовам <span class="code">read()</span> и <span class="code">write()</span>.
  </div>
  <div class="abzac">
   Возможные комбинациями констант параметра <span class="code">flags</span> системного вызова <span class="code">send()</span>:
  </div>
  <ul>
   <li>
    <span class="code">MSG_PEEK</span> - процесс может просматривать данные, не "получая" их;
   </li>
   <li>
    <span class="code">MSG_OOB</span> - обычные данные пропускаются; процесс принимает только срочные данные, например, сигнал прерывания;
   </li>
   <li>
    <span class="code">MSG_WAITALL</span> - возврат из вызова <span class="code">recv()</span> произойдет только после получения всех данных.
   </li>
  </ul>
  <div class="abzac">
   Возможные комбинациями констант параметра <span class="code">flags</span> системного вызова <span class="code">recv()</span>:
  </div>
  <ul>
   <li>
    <span class="code">MSG_OOB</span> - передать срочные (out of band) данные;
   </li>
   <li>
    <span class="code">MSG_DONTROUTE</span> - при передаче сообщения игнорируются условия маршрутизации протокола более низкого уровня. 
    Обычно это означает, что сообщение посылается по прямому, а не по самому быстрому маршруту (самый быстрый 
    маршрут не обязательно прямой и может зависеть от текущего распределения нагрузки сети). 
   </li>
  </ul>
  <div class="abzac">
   Данные операции выполняются и в программе сервера и в программе клиента.
  </div>

  <div class="header">
   7. Закрытие TCP-соединения
  </div>
  <div class="abzac">
   Закрываются сокеты так же, как и обычные дескрипторы файлового ввода/вывода, - при помощи системного вызова 
   <span class="code">close()</span>. Для сокета <span class="code">SOCK_STREAM</span> ядро гарантирует, что все записанные в сокет данные будут 
   переданы принимающему процессу. 
  </div>
  <div class="abzac">
   Данные операции выполняются и в программе сервера, и в программе клиента.
  </div>

  <div class="header">
   Варианты заданий
  </div>
  <ol>
   <li>
    Эмуляция DNS сервера. Клиент подсоединяется к серверу, IP которого хранится в файле <span class="code">dns.url</span>, и делает ему запрос 
    на подключение к серверу "Имя сервера". DNS-сервер имеет список, хранящийся в файле о соответствии имен серверов и 
    IP-адресов. Если в списке нет "имени сервера", запрошенного клиентом, то сервер DNS подключается последовательно к 
    другим серверам, хранящимся в файле dns.url, и т.д. Если сервер не найден, клиенту возвращается соответствующее сообщение. 
   </li>

   <li>
    Организовать чат. К серверу подключаются клиенты. При подключении клиента сервер спрашивает имя, под которым 
    клиент будет известен в соединении. Сервер хранит IP-адреса подключаемых клиентов и их имена. Все сообщения 
    каждого клиента рассылаются остальным в виде <span class="code">"имя_клиента - сообщение"</span>. Сообщения рассылаются сервером всем 
    клиентам также при вхождении в связь нового клиента, и выходе какого-либо клиента.
   </li>

   <li>
    Организовать взаимодействие типа клиент-сервер. Клиенты подключаются к первому серверу и передают запрос 
    на получение определенного файла. Если этого файла нет, сервер подключается ко второму серверу и ищет файл 
    там. Затем либо найденный файл пересылается клиенту, либо высылается сообщение, что такого файла нет. 
   </li>

   <li>
    Организовать взаимодействие типа клиент-сервер. Клиент отсылает строку серверу. Сервер отсылает данную строку 
    на другие сервера, список которых хранится в файле, а там уже осуществляется поиск файлов содержащих данную 
    строку. Результаты поиска отсылаются клиенту. 
   </li>

   <li>
    Организовать взаимодействие типа клиент-сервер. Сервер при подключении к нему нового клиента высылает 
    список IP-адресов уже подключенных клиентов. А остальным клиентам рассылается сообщение в виде IP-адреса 
    о том, что подключился такой-то клиент.
   </li>

   <li>
    Организовать взаимодействие типа клиент-сервер. К серверу одновременно может подключиться только один клиент. 
    Остальные клиенты заносятся в очередь, и им высылается сообщение об ожидании освобождения сервера.
   </li>

   <li>
    Организовать взаимодействие типа клиент-сервер. Клиент при входе в связь с сервером должен ввести пароль. 
    Разрешено сделать три попытки. Если пароль не верен, сервер должен блокировать IP-адрес клиента на 5 минут. 
   </li>

   <li>
    Сервер, моделирующий работу примитивной СУБД, хранит единственную таблицу в оперативной памяти. Клиенты подключаются к серверу, чтобы получить подробную информацию об хранящихся в таблице объектах. Для этого клиенты пересылают серверу строку, являющуюся уникальным ключом, который однозначно характеризует какой-либо объект, хранящийся в таблице. Сервер ищет в таблице объект с таким ключом и возвращает клиенту полную информацию об объекте, либо сообщает об отсутствии искомого объекта.
   </li>

   <li>
    Организовать взаимодействие типа клиент-сервер. Клиент делает запрос серверу на выполнение какой-либо 
    команды. Сервер выполняет эту команду и возвращает результаты клиенту.
   </li>

   <li>
    Организовать взаимодействие типа клиент-сервер. Клиент делает запрос серверу о передаче файлов с 
    определенным расширением из указанной директории. Сервер сканирует указанную директорию и отправляет 
    клиенту список файлов, удовлетворяющих запросу.
   </li>
  </ol>

  <div class="header">
   Контрольные вопросы
  </div>
  <ol>
   <li>
    Какова структура IP-адреса?
   </li>
   <li>
    Как поместить и извлечь IP-адрес из структуры сокета?
   </li>
   <li>
    В чем разница между моделями TCP-соединения и дейтаграмм?
   </li>
   <li>
    Каковы основные шаги межпроцессного взаимодействия в модели TCP-соединения? 
   </li>
   <li>
    Каковы основные шаги межпроцессного взаимодействия в модели дейтаграмм? 
   </li>
   <li>
    Как занести в структуру сокета IP-адрес своего компьютера?
   </li>
   <li>
    Каким образом извлечь информацию о клиенте после установки TCP-соединения? 
   </li>
   <li>
    Какова реакция системных вызовов посылки и приема сообщений в модели TCP-соединения при разрыве связи?
   </li>
  </ol>

 </body>
</html>
