<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

 <head>
  <title>Лабораторная работа № 7</title>
  <meta http-equiv=Content-Type content="text/html; charset=windows-1251">
  <link rel="stylesheet" type="text/css" href="textstyle.css">
  <!--base href="http://ami.nstu.ru/~vms/method6/"-->
 </head>

 <body>

  <div class="header">
   Лабораторная работа № 7
  </div>
  <div class="mainheader">
   Межпроцессное взаимодействие программ
  </div>
  
  <div class="header">
   Цель работы
  </div>
  <div class="abzac">
   Освоение средств IPC. Написание программ, использующих механизм семафоров, очередей сообщений, сегментов разделяемой памяти.
  </div>
  
  <div class="header">
   Содержание работы
  </div>
  <ol>
   <li>
    Ознакомиться с заданием к лабораторной работе. 
   </li>
   <li>
    Ознакомиться с основными понятиями механизма IPC.
   </li>
   <li>
    Изучить набор системных вызовов, обеспечивающих решение задачи. 
   </li>
   <LI>
    Отладить и оттестировать составленную программу, используя инструментарий ОС UNIX. 
   </li>
   <li>
    Защитить лабораторную работу, ответив на контрольные вопросы.
   </li>
  </ol>

  <div class="header">
   Методические указания к лабораторной работе
  </div>
  <div class="abzac">
   Механизм IPC (Inter-Process Communication Facilities) включает:
  </div>
  <ul>
   <li>
    средства, обеспечивающие возможность синхронизации процессов при доступе к совместно используемым ресурсам (семафоры - semaphores);
   </li>
   <li>
    средства, обеспечивающие возможность посылки процессом сообщений другому произвольному процессу (очереди сообщений - message queries);
   </li>
   <li>
    средства, обеспечивающие возможность наличия общей для процессов памяти (сегменты разделяемой памяти - shared memory segments).
   </li>
  </ul>
  <div class="abzac">
   Наиболее общим понятием IPC является ключ, хранимый в общесистемной таблице и обозначающий объект межпроцессного 
   взаимодействия, доступный нескольким процессам. Обозначаемый ключом объект может быть очередью сообщений, набором 
   семафоров или сегментом разделяемой памяти. Ключ имеет тип <span class="code">key_t</span>, состав которого зависит 
   от реализации и определяется в файле <span class="code">sys/types.h</span>. Ключ используется для создания объекта 
   межпроцессного взаимодействия или получения доступа к существующему объекту. Обе операции выполняются посредством 
   операции <span class="code">get</span>. Результатом операции <span class="code">get</span> является его целочисленный 
   идентификатор, который может использоваться в других функциях межпроцессного взаимодействия.
  </div>

  <div class="header">
   Семафоры
  </div>

  <div class="abzac">
   Для работы с семафорами поддерживаются три системных вызова:
  </div>
  <ul>
   <li>
    <span class="code">semget()</span> для создания и получения доступа к набору семафоров;
   </li>
   <li>
    <span class="code">semop()</span> для манипулирования значениями семафоров (это тот системный вызов, который позволяет 
    процессам синхронизироваться на основе использования семафоров);
   </li>
   <li>
    <span class="code">semctl()</span> для выполнения разнообразных управляющих операций над набором семафоров. 
   </li>
  </ul>
  <div class="abzac">
   Прототипы перечисленных системных вызовов описаны в файлах:
  </div>
<pre>
#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt;
</pre>
  <div class="abzac">
   Системный вызов <span class="code">semget()</span> имеет следующий синтаксис:
  </div>
<pre>
semid = int semget(key_t key, int count, int flag);
</pre>
  <div class="abzac">
   Его параметрами являются ключ (<span class="code">key</span>) набора семафоров и дополнительные флаги (<span class="code">flags</span>), 
   определенные в <span class="code">&lt;sys/ipc.h&gt;</span>, число семафоров в наборе семафоров (<span class="code">count</span>), обладающих одним и тем же ключом. 
   Системный вызов возвращает идентификатор набора семафоров <span class="code">semid</span>. После вызова <span class="code">semget()</span> 
   индивидуальный семафор идентифицируется идентификатором набора семафоров и номером семафора в этом наборе.
  </div>
  <div class="abzac">
   Флаги системного вызова <span class="code">semget()</span> приведены в таблице:
  </div>
  <table>
   <tr>
    <td class="code">
     IPC_CREAT
    </td>
    <td>
     <span class="code">semget()</span> создает новый семафор для данного ключа. Если флаг <span class="code">IPC_CREAT</span> не задан, 
     а набор семафоров с указанным ключом уже существует, то обращающийся процесс получит идентификатор существующего набора семафоров.
    </td>
   </tr>

   <tr>
    <td class="code">
     IPC_EXLC
    </td>
    <td>
     Флаг <span class="code">IPC_EXLC</span> вместе с флагом <span class="code">IPC_CREAT</span> предназначен для создания (и только 
     для создания) набора семафоров. Если набор семафоров уже существует, <span class="code">semget()</span> возвратит -1, а 
     системная переменная <span class="code">errno</span> будет содержать значение <span class="code">EEXIST</span>.
    </td>
   </tr>
  </table>
  <div class="abzac">
   Младшие 9 бит флага задают права доступа к набору семафоров.
  </div>
  <div class="abzac">
   Системный вызов <span class="code">semctl()</span> имеет формат:
  </div>
<pre>
int semctl (int semid, int sem_num, int command, union semun arg);
</pre>
  <div class="abzacWithoutIndent">
   где <span class="code">semid</span> - это идентификатор набора семафоров, <span class="code">sem_numb</span> - 
   номер семафора в группе, <span class="code">command</span> - код операции, а <span class="code">arg</span> - 
   указатель на структуру, содержимое которой интерпретируется по-разному, в зависимости от операции.
  </div>
  <div class="abzac">
   Структура <span class="code">msg</span> имеет вид:
  </div>
<pre>
union semun 
{
 int val;
 struct semid_ds *buf;
 unsigned short *array; 
};
</pre>
  <div class="abzac">
   С помощью <span class="code">semctl()</span> можно:
  </div>
  <ul>
   <li>
    уничтожить набор семафоров или индивидуальный семафор в указанной группе (<span class="code">IPC_RMID</span>);
   </li>
   <li>
    вернуть значение отдельного семафора (<span class="code">GETVAL</span>) или всех семафоров (<span class="code">GETALL</span>);
   </li>
   <li>
    установить значение отдельного семафора (<span class="code">SETVAL</span>) или всех семафоров (<span class="code">SETALL</span>); 
   </li>
   <li>
    вернуть число семафоров в наборе семафоров (<span class="code">GETPID</span>).
   </li>
  </ul>
  <div class="abzac">
   Основным системным вызовом для манипулирования семафором является:
  </div>
<pre>
int semop (int semid, struct sembuf *op_array, count);
</pre>
  <div class="abzacWithoutIndent">
   где <span class="code">semid</span> - это ранее полученный дескриптор группы семафоров, <span class="code">op_array</span> - 
   массив структур <span class="code">sembuf</span>, определенных в файле <span class="code">&lt;sys/sem.h&gt;</span> и 
   содержащих описания операций над семафорами группы, а <span class="code">count</span> - размер этого массива. 
   Значение, возвращаемое системным вызовом, является значением последнего обработанного семафора. Каждый 
   элемент массива <span class="code">op_array</span> имеет следующую структуру (структура <span class="code">sembuf</span>): 
  </div>
  <ul>
   <li>
    номер семафора в указанном наборе семафоров;
   </li>
   <li>
    операция над семафором;
   </li>
   <li>
    флаги.
   </li>
  </ul>
  <div class="abzac">
   Если указанные в массиве <span class="code">op_array</span> номера семафоров не выходят за пределы общего размера 
   набора семафоров, то системный вызов последовательно меняет значение семафора (если это возможно) в соответствии 
   со значением поля "операция". Возможны три случая:
  </div>
  <ol>
   <li>
    Отрицательное значение <span class="code">sem_op</span>:
    <ul>
     <li>
      если значение поля операции <span class="code">sem_op</span> отрицательно, и его абсолютное значение меньше или 
      равно значению семафора <span class="code">semval</span>, то ядро прибавляет это отрицательное значение к значению 
      семафора;
     </li>
     <li>
      если в результате значение семафора стало нулевым, то ядро активизирует все процессы, ожидающие нулевого 
      значения этого семафора;
     </li>
     <li>
      если же значение поля операции <span class="code">sem_op</span> по абсолютной величине больше семафора 
      <span class="code">semval</span>, то ядро увеличивает на единицу число процессов, ожидающих увеличения 
      значения семафора и усыпляет текущий процесс до наступления этого события.
     </li>
    </ul>
   </li>

   <li>
    Положительное значение <span class="code">sem_op</span>.<br>
    Если значение поля операции <span class="code">sem_op</span> положительно, то оно прибавляется к значению 
    семафора <span class="code">semval</span>, а все процессы, ожидающие увеличения значения семафора, 
    активизируются (пробуждаются в терминологии UNIX).
   </li>

   <li>
    Нулевое значение <span class="code">sem_op</span>:
    <ul>
     <li>
      eсли значение поля операции <span class="code">sem_op</span> равно нулю, то если значение семафора 
      <span class="code">semval</span> также равно нулю, выбирается следующий элемент массива 
      <span class="code">op_array</span>;
     </li>
     <li>
      если же значение семафора <span class="code">semval</span> отлично от нуля, то ядро увеличивает 
      на единицу число процессов, ожидающих нулевого значения семафора, а обратившийся процесс переводится в состояние 
      ожидания.
     </li>
    </ul>
   </li>
  </ol>
  <div class="abzac">
   При использовании флага <span class="code">IPC_NOWAIT</span> ядро ОС UNIX не блокирует текущий процесс, а лишь 
   сообщает в ответных параметрах о возникновении ситуации, приведшей бы к блокированию процесса при 
   отсутствии флага <span class="code">IPC_NOWAIT</span>.
  </div>

  <div class="header">
   Очереди сообщений
  </div>
  <div class="abzac">
   Для обеспечения возможности обмена сообщениями между процессами механизм очередей поддерживается 
   следующими системными вызовами:
  </div>
  <ul>
   <li>
    <span class="code">msgget()</span> для образования новой очереди сообщений или получения дескриптора существующей очереди;
   </li>
   <li>
    <span class="code">msgsnd()</span> для постановки сообщения в указанную очередь сообщений;
   </li>
   <li>
    <span class="code">msgrcv()</span> для выборки сообщения из очереди сообщений;
   </li>
   <li>
    <span class="code">msgctl()</span> для выполнения ряда управляющих действий.
   </li>
  </ul>
  <div class="abzac">
   Прототипы перечисленных системных вызовов описаны в файлах:
  </div>
<pre>
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
</pre>
  <div class="abzac">
   По системному вызову <span class="code">msgget()</span> в ответ на ключ (<span class="code">key</span>) и набор флагов 
   (полностью аналогичны флагам в системном вызове <span class="code">semget()</span>) ядро либо создает 
   новую очередь сообщений и возвращает пользователю идентификатор созданной очереди, либо находит элемент таблицы очередей 
   сообщений, содержащий указанный ключ, и возвращает соответствующий идентификатор очереди: 
  </div>
<pre>
int msgqid = msgget(key_t key, int flag);
</pre>
  <div class="abzac">
   Для помещения сообщения в очередь служит системный вызов <span class="code">msgsnd()</span>:
  </div>
<pre>
int msgsnd (int msgqid, void *msg, size_t size, int flag);
</pre>
  <div class="abzacWithoutIndent">
   где <span class="code">msg</span> - это указатель на структуру длиной <span class="code">size</span>, 
   содержащую определяемый пользователем целочисленный тип сообщения и символьный массив-сообщение. 
  </div>
  <div class="abzac">
   Структура <span class="code">msg</span> имеет вид:
  </div>
<pre>
struct msg 
{
 long mtype;            /* тип сообщения */
 char mtext[SOMEVALUE]; /* текст сообщения (SOMEVALUE - любое) */
}; 
</pre>
  <div class="abzac">
   Параметр <span class="code">flag</span> определяет действия ядра при выходе за пределы допустимых размеров 
   внутренней буферной памяти (флаг <span class="code">IPC_NOWAIT</span> со значением, рассмотренным выше).
  </div>
  <div class="abzac">
   Условиями успешной постановки сообщения в очередь являются:
  </div>
  <ul>
   <li>
    наличие прав процесса по записи в данную очередь сообщений;
   </li>
   <li>
    непревышение длиной сообщения заданного системой верхнего предела;
   </li>
   <li>
    положительное значение указанного в сообщении типа сообщения.
   </li>
  </ul>
  <div class="abzac">
   Если же оказывается, что новое сообщение невозможно буферизовать в ядре по причине превышения верхнего предела суммарной 
   длины сообщений, находящихся в данной очереди сообщений (флаг <span class="code">IPC_NOWAIT</span> при этом отсутствует), 
   то обратившийся процесс откладывается (усыпляется) до тех пор, пока очередь сообщений не разгрузится процессами, 
   ожидающими получения сообщений.
  </div>
  <div class="abzac">
   Для приема сообщения используется системный вызов <span class="code">msgrcv()</span>:
  </div>
<pre>
int msgrcv (int msgqid, void *msg, size_t size, long msg_type, int flag);
</pre>
  <div class="abzac">
   Системный вызов <span class="code">msgctl()</span>:
  </div>
<pre>
int msgctl (int msgqid, int command, struct msqid_ds *msg_stat);
</pre>
  <div class="abzacWithoutIndent">
   используется:
  </div>
  <ul>
   <li>
    для опроса состояния описателя очереди сообщений (<span class="code">command = IPC_STAT</span>) и помещения его в структуру <span class="code">msg_stat</span>;
   </li>
   <li>
    изменения его состояния (<span class="code">command = IPC_SET</span>), например, изменения прав доступа к очереди; 
   </li>
   <li>
    для уничтожения указанной очереди сообщений (<span class="code">command = IPC_RMID</span>).
   </li>
  </ul>

  <div class="header">
   Работа с разделяемой памятью
  </div>
  <div class="abzac">
   Для работы с разделяемой памятью используются системные вызовы:
  </div>
  <ul>
   <li>
    <span class="code">shmget()</span> создает новый сегмент разделяемой памяти или находит существующий сегмент с тем же ключом; 
   </li>
   <li>
    <span class="code">shmat()</span> подключает сегмент с указанным описателем к виртуальной памяти обращающегося процесса; 
   </li>
   <li>
    <span class="code">shmdt()</span> отключает от виртуальной памяти ранее подключенный к ней сегмент с указанным виртуальным адресом начала; 
   </li>
   <li>
    <span class="code">shmctl()</span> служит для управления разнообразными параметрами, связанными с существующим сегментом. 
   </li>
  </ul>
  <div class="abzac">
   Прототипы перечисленных системных вызовов описаны в файлах:
  </div>
<pre>
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
</pre>  
  <div class="abzac">
   После того, как сегмент разделяемой памяти подключен к виртуальной памяти процесса, этот процесс может обращаться к 
   соответствующим элементам памяти с использованием обычных машинных команд чтения и записи.
  </div>
  <div class="abzac">
   Системный вызов
  </div>
<pre>
int shmid = shmget (key_t key, size_t size, int flag);
</pre>
  <div class="abzacWithoutIndent">
   на основании параметра <span class="code">size</span> определяет желаемый размер сегмента в байтах. Если в 
   таблице разделяемой памяти находится элемент, содержащий заданный ключ, и права доступа не противоречат 
   текущим характеристикам обращающегося процесса, то значением системного вызова является идентификатор существующего сегмента. 
   В противном случае создается новый сегмент с размером не меньше установленного в системе минимального размера сегмента 
   разделяемой памяти и не больше установленного максимального размера. Создание сегмента не означает немедленного выделения 
   под него основной памяти и это действие откладывается до выполнения первого системного вызова подключения сегмента к 
   виртуальной памяти некоторого процесса. Флаги <span class="code">IPC_CREAT</span> и <span class="code">IPC_EXCL</span> 
   аналогичны рассмотренным выше.
  </div>
  <div class="abzac">
   Подключение сегмента к виртуальной памяти выполняется путем обращения к системному вызову <span class="code">shmat()</span>:
  </div>
<pre>
void *virtaddr = shmat(int shmid, void *daddr, int flags);
</pre>
  <div class="abzac">
   Параметр <span class="code">shmid</span> - это ранее полученный идентификатор сегмента, а <span class="code">daddr</span> - 
   желаемый процессом виртуальный адрес, который должен соответствовать началу сегмента в виртуальной памяти. Значением системного вызова 
   является фактический виртуальный адрес начала сегмента. Если значением <span class="code">daddr</span> является 
   <span class="code">NULL</span>, ядро выбирает наиболее удобный виртуальный адрес начала сегмента.
  </div>
  <div class="abzac">
   Флаги системного вызова <span class="code">shmat()</span>:
  </div>
  <table>
   <tr>
    <td class="code">
     SHM_RDONLY
    </td>
    <td>
     ядро подключает участок памяти только для чтения.
    </td>
   </tr>

   <tr>
    <td class="code">
     SHM_RND
    </td>
    <td>
     определяет, если возможно, способ обработки ненулевого значения <span class="code">daddr</span>.
    </td>
   </tr>
  </table>
  <div class="abzac">
   Для отключения сегмента от виртуальной памяти используется системный вызов <span class="code">shmdt()</span>: 
  </div>
<pre>
int shmdt(*daddr);
</pre>
  <div class="abzacWithoutIndent">
   где <span class="code">daddr</span> - это виртуальный адрес начала сегмента в виртуальной памяти, ранее полученный от 
   системного вызова <span class="code">shmat()</span>.
  </div>
  <div class="abzac">
   Системный вызов <span class="code">shmctl()</span>
  </div>
<pre>
 int shmctl (int shmid, int command, struct shmid_ds *shm_stat);
</pre>
  <div class="abzacWithoutIndent">
   по синтаксису и назначению полностью аналогичен <span class="code">msgctl()</span>.
  </div>


  <div class="header">
   Варианты заданий
  </div>
  <ol>
   <li>
    Два дочерних процесса выполняют некоторые циклы работ, передавая после окончания очередного цикла через очередь сообщений 
    родительскому процессу очередные четыре строки некоторого стихотворения, при этом первый процесс передает нечетные 
    четырехстишья, второй - четные. Циклы работ процессов не сбалансированы по времени. Родительский процесс компонует 
    из передаваемых фрагментов законченное стихотворение и выводит его по завершении работы обоих процессов. Решить 
    задачу с использованием аппарата семафоров.
   </li>

   <li>
    Два дочерних процесса выполняют некоторые циклы работ, передавая после окончания очередного цикла через один и тот же 
    сегмент разделяемой памяти родительскому процессу очередные четыре строки некоторого стихотворения, при этом первый 
    процесс передает нечетные четырехстишья, второй - четные. Циклы работ процессов не сбалансированы по времени. 
    Родительский процесс компонует из передаваемых фрагментов законченное стихотворение и выводит его по завершении 
    работы обоих процессов. Решить задачу с использованием аппарата семафоров. 
   </li>

   <li>
    Четыре дочерних процесса выполняют некоторые циклы работ, передавая после окончания очередного цикла через один и тот 
    же сегмент разделяемой памяти родительскому процессу очередную строку некоторого стихотворения, при этом первый процесс 
    передает 1-ю, 5-ю, 9-ю и т.д. строки, второй - 2-ю, 6-ю, 10-ю и т.д. строки, третий - 3-ю, 7-ю, 11-ю и т.д. строки, 
    четвертый - 4-ю, 8-ю, 12-ю и т.д. строки. Циклы работ процессов не сбалансированы по времени. Родительский процесс 
    компонует из передаваемых фрагментов законченное стихотворение и выводит его по завершении работы всех процессов. 
    Решить задачу с использованием аппарата семафоров.
   </li>

   <li>
    Программа моделирует работу примитивной СУБД, хранящей единственную таблицу в оперативной памяти. Выполняя некоторые 
    циклы работ, K порожденных процессов посредством очереди сообщений передают родительскому процессу номер строки, которую 
    нужно удалить из таблицы. Родительский процесс выполняет указанную операцию и возвращает содержимое удалённой строки.    
   </li>

   <li>
    Программа моделирует работу примитивной СУБД, хранящей единственную таблицу в оперативной памяти. Выполняя некоторые 
    циклы работ, K порожденных процессов посредством очереди сообщений передают родительскому процессу номер строки и её 
    содержимое, на которое нужно изменить хранящиеся в ней данные. Родительский процесс выполняет указанную операцию и 
    возвращает старое содержимое изменённой строки.
   </li>

   <li>
    Программа моделирует работу примитивной СУБД, хранящей единственную таблицу в оперативной памяти. Выполняя некоторые 
    циклы работ, K порожденных процессов посредством очереди сообщений передают родительскому процессу содержимое строки, 
    которую нужно добавить в таблицу. Родительский процесс проверяет, нет ли в таблице такой строки, и, если нет, добавляет 
    строку и возвращает количество хранящихся в таблице строк.
   </li>

   <li>
    Четыре дочерних процесса выполняют некоторые циклы работ, передавая после окончания очередного цикла через очередь 
    сообщений родительскому процессу очередную строку некоторого стихотворения, при этом первый процесс передает 1-ю, 
    5-ю, 9-ю и т.д. строки, второй - 2-ю, 6-ю, 10-ю и т.д. строки, третий - 3-ю, 7-ю, 11-ю и т.д. строки, четвертый - 
    4-ю, 8-ю, 12-ю и т.д. строки. Циклы работ процессов не сбалансированы по времени. Родительский процесс компонует 
    из передаваемых фрагментов законченное стихотворение и выводит его по завершении работы всех процессов. Решить 
    задачу с использованием аппарата семафоров. 
   </li>

   <li>
    Родительский процесс помещает в сегмент разделяемой памяти имена программ из предыдущих лабораторных работ, которые 
    могут быть запущены. Выполняя некоторые циклы работ, порожденные процессы случайным образом выбирают имена программ 
    из таблицы сегмента разделяемой памяти, запускают эти программы, и продолжают свою работу. Посредством аппарата 
    семафоров должно быть обеспечено, чтобы не были одновременно запущены две программы от одного процесса. В процессе 
    работы через очередь сообщений родительский процесс информируется, какие программы и от имени кого запущены.
   </li>

   <li>
    Родительский процесс помещает в сегмент разделяемой памяти имена программ из предыдущих лабораторных работ, которые 
    могут быть запущены. Выполняя некоторые циклы работ, порожденные процессы случайным образом выбирают имена программ 
    из таблицы сегмента разделяемой памяти, запускают эти программы, и продолжают свою работу. Посредством аппарата 
    семафоров должно быть обеспечено, чтобы не были одновременно запущены две одинаковые программы. В процессе работы 
    через очередь сообщений родительский процесс информируется, какие программы и от имени кого запущены.
   </li>

   <li>
    Программа моделирует работу монитора обработки сообщений. Порожденные процессы, обладающие различными приоритетами 
    и выполняющие некоторые циклы работ, посредством очереди сообщений передают родительскому процессу имена программ из 
    предыдущих лабораторных работ, которые им должны быть запущены. Родительский процесс, обрабатывая сообщения в 
    соответствии с их приоритетами, следит, чтобы одновременно было запущено не более трех программ.
   </li>
  </ol>

  <div class="header">
   Контрольные вопросы
  </div>
  <ol>
   <li>
    В чем разница между двоичным и общим семафорами?
   </li>
   <li>
    Чем отличаются <span class="code">P()</span> и <span class="code">V()</span>-операции от обычных операций увеличения 
    и уменьшения на единицу?
   </li>
   <li>
    Для чего служит набор программных средств IPC? 
   </li>
   <li>
    Для чего введены массовые операции над семафорами в ОС UNIX? 
   </li>
   <li>
    Каково назначение механизма очередей сообщений?
   </li>
   <li>
    Какие операции над семафорами существуют в ОС UNIX? 
   </li>
   <li>
    Каково назначение системного вызова <span class="code">msgget()</span>? 
   </li>
   <li>
    Какие условия должны быть выполнены для успешной постановки сообщения в очередь? 
   </li>
   <li>
    Как получить информацию о владельце и правах доступа очереди сообщений? 
   </li>
   <li>
    Каково назначение системного вызова <span class="code">shmget()</span>?
   </li>
  </ol>

 </body>
</html>
