#pragma once

#include <string>
#include <math.h>
#include <stdio.h>

#include "solver_LU.h"

using namespace std;

//Метод конечных элементов для одномерной не стационарной нелизненой задачи

typedef double(*func_t)(double, double); //указалетль на функцию двух переменных (пространства и времени)
typedef double(*func)(double); //указатель на функцию одной переменной (предположительно - времени)

//Стуркутра описывающая элемент - отрезок
struct element{
	int node1, node2;
};

class unlin_FEM{
 public:
	 void init(string node_file, string u0_file, string info_file);
	 //Метод для инициализации класса, выполняет чтение из файлов нужных данных
	 //node_file - имя файла, где гранятся данные о количестве и координатах вершин
	 //u0_file - имя файла, где хранятся начальные уловия
	 //info_file - имя файла, где хранится информация о ветки по времени (начальный шаг и коэффциент разрядки), так же макс. число итераций на слое и требуемая точность

	 void init_coefs(func_t set_lambda, func_t set_f);
	 //Устанавливает коэффициенты уравнения

	 void init_sigma(double set_c);
	 //Устанавливает коэффицент для сигма, который задаётся как: sigma(u_x, x, t) = ((u_x)^2 + c) * x


	 void init_bounds(int set_b_l, int set_b_r, func bound_l1, func bound_l2, func bound_r1, func bound_r2);
	 //Метод для инициаилазции краевых условий
	 //set_b_l - тип левых краевых
	 //set_b_r - при правых краевых
	 //Дальше параметры - это функции для краевых условий в случае первых или вторых краевых, допустим слева в третий пораметр подаётся функция, а в четвёртый - NULL
	 //В случае третих краевых в l1 - бетта, в l2 - u_betta (ну или r1, r2)

	double get_current_time();
	//Метод для получения текущего времени

	void set_analytic(func_t set_u);
	//Устанавливаем наалитическое решение

	double operator () (double x);
	//Перегрузка оператора, для получения значения функции на текущем временном слое

	void simple_iteration_step();
	//Сделать шаг по времени методом простой итерации

	void Newton_step();
	//Сделать шаг по времени методом Ньютона

	void out_q(string file_out);
	//Вывод q в файл, с дописыванием

 private:
	 double* nodes; //массив координат узлов
	 element* elements; //массив элементов
	 int nodes_n; //количество узлов
	 int elements_n; //количество эллементов

	 func_t lambda, f; //коэффцииенты уравнения
	 double sigma_c; //коэффициент для сигма
	 double sigma(double u_x, double x); //функция для вычисления сигма
	 double sigma_ux(double u_x, double x); //производная сигма по u_x

	 func_t analytic; //Аналитическое решение
	 
	 double* q_last; //массив весов с предыдущего временого слоя
	 double* q_new; //массив узлов, с нового временого слоя
	 double* q_temp; //массив узлов, для промежуточных итераций
	 double* q_min; //массив, используеммый для минимизации невязки
	 double* q_min_rp; //массив, используеммый для минимизации невязки хранящий правую часть матрицы
	 double* q_min_R; //массив, используемый для минимизации - вектор невзяки. Так же использутеся для определения невязки, при выходе из процесса решения СНУ

	 double *dia_0, *dia_p1, *dia_m1; //диагонали матрицы

	 double t_now; //текущее время
	 double t_new; //следующее время
	 double h_t; //шаг по времени
	 double k_t; //коэффицент разрядки по времени
	 int iter_max; //макимальнео число итераций на одном временом слое
	 double eps; //точность для решения нелинейной системы
	 
	 int bound_type_left,  bound_type_right; // тип краевых условий справа и слева, значения соответсвнно могут быть 1, 2 или 3
	 func* bounds_l; //функции для краевых условйи слева
	 func* bounds_r; //функции для краевых условий справа

	 double norm_q_dif(double* q1, double* q2); // ||q1 - q2||
	 double norm_q(double* q1); // ||q||

	 void matrix_gen_si(double* q_n, double* q_t); 
	 //Метод для генерации матрицы (для метода простой итерации) Поскольку он нужен и при оставлении СЛАУ и при нахождении параметра релаксации - чтобы не дублировать код
	 void matrix_gen_Newton(double* q_n, double* q_t);
	 //Метод генерации матрицы для метода Ньютона
	 //q_n - значения на предыдущей итерации
	 //q_t - будующая правая часть и затем значеня на новой итерации

	 double w_min(); //Нахождение параметра релаксации
	 double w_min_func(double w); //Функция для минимизации
	 void w_min_find_area(double& a, double& b, double delta); //Нахождение отрезка, содержшего минимум
	 double w_min_golden(double a, double b, double eps_min); //Минимизация, методом золотого сечения
};
